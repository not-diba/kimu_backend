package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"kimu_backend/cmd/app/domain/models"
	"kimu_backend/graph"

	"github.com/lib/pq"
)

// Recipes is the resolver for the recipes field.
func (r *queryResolver) Recipes(ctx context.Context) ([]*models.Recipe, error) {
	rows, err := r.DB.Query(`SELECT id, "recipeName", "categoryName", duration, people, description, amount, "imageUrl", instructions FROM "Recipe"`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var recipes []*models.Recipe
	for rows.Next() {
		var recipe models.Recipe
		if err := rows.Scan(
			&recipe.ID,
			&recipe.RecipeName,
			&recipe.CategoryName,
			&recipe.Duration,
			&recipe.People,
			&recipe.Description,
			&recipe.Amount,
			&recipe.ImageUrl,
			pq.Array(&recipe.Instructions),
		); err != nil {
			return nil, err
		}

		ingredients, err := r.getIngredientsForRecipe(recipe.ID)
		if err != nil {
			return nil, err
		}
		recipe.Ingredients = ingredients

		nutrition, err := r.getNutritionForRecipe(recipe.ID)
		if err != nil {
			return nil, err
		}
		recipe.Nutrition = nutrition

		recipes = append(recipes, &recipe)
	}
	if err = rows.Err(); err != nil {
		return nil, err
	}

	return recipes, nil
}

func (r *queryResolver) getIngredientsForRecipe(recipeID string) ([]models.Ingredient, error) {
	rows, err := r.DB.Query(`SELECT name, quantity FROM "Ingredient" WHERE "recipeId" = $1`, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var ingredients []models.Ingredient
	for rows.Next() {
		var ingredient models.Ingredient
		if err := rows.Scan(&ingredient.Name, &ingredient.Quantity); err != nil {
			return nil, err
		}
		ingredients = append(ingredients, ingredient)
	}
	return ingredients, nil
}

func (r *queryResolver) getNutritionForRecipe(recipeID string) ([]models.Nutrition, error) {
	rows, err := r.DB.Query(`SELECT "nutritionItem", quantity FROM "Nutrition" WHERE "recipeId" = $1`, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var nutrition []models.Nutrition
	for rows.Next() {
		var nutri models.Nutrition
		if err := rows.Scan(&nutri.NutritionItem, &nutri.Quantity); err != nil {
			return nil, err
		}
		nutrition = append(nutrition, nutri)
	}
	return nutrition, nil
}

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
